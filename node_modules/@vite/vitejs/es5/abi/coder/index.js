"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reader = exports.Writer = exports.Coder = exports.BigNumber = void 0;
var BigNumber = require("bn.js");
exports.BigNumber = BigNumber;
var utils_1 = require("../utils");
var Coder = (function () {
    function Coder(name, type, localName, dynamic) {
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    Coder.prototype.pack = function (writer, coders, values) {
        var arrayValues = null;
        if (Array.isArray(values)) {
            arrayValues = values;
        }
        else if (values && typeof (values) === 'object') {
            var unique_1 = {};
            arrayValues = coders.map(function (coder) {
                var name = coder.localName;
                if (!name) {
                    throw new Error("cannot encode object for signature with missing names: ".concat(coder.type));
                }
                if (unique_1[name]) {
                    throw new Error("cannot encode object for signature with duplicate names: ".concat(name));
                }
                unique_1[name] = true;
                return values[name];
            });
        }
        else {
            throw new Error("invalid tuple value: ".concat(values));
        }
        if (coders.length !== arrayValues.length) {
            throw new Error("types/value length mismatch: ".concat(values));
        }
        var staticWriter = new Writer(writer.wordSize);
        var dynamicWriter = new Writer(writer.wordSize);
        var updateFuncs = [];
        coders.forEach(function (coder, index) {
            var value = arrayValues[index];
            if (coder.dynamic) {
                var dynamicOffset_1 = dynamicWriter.length;
                coder.encode(dynamicWriter, value);
                var updateFunc_1 = staticWriter.writeUpdatableValue();
                updateFuncs.push(function (baseOffset) {
                    updateFunc_1(baseOffset + dynamicOffset_1);
                });
            }
            else {
                coder.encode(staticWriter, value);
            }
        });
        updateFuncs.forEach(function (func) {
            func(staticWriter.length);
        });
        var length = writer.appendWriter(staticWriter);
        length += writer.appendWriter(dynamicWriter);
        return length;
    };
    Coder.prototype.unpack = function (reader, coders) {
        var _this = this;
        var values = [];
        var baseReader = reader.subReader(0);
        coders.forEach(function (coder) {
            var value = null;
            if (coder.dynamic) {
                var offset = reader.readValue();
                var offsetReader = baseReader.subReader(offset.toNumber());
                value = coder.decode(offsetReader);
            }
            else {
                value = coder.decode(reader);
            }
            if (value !== undefined) {
                values.push(value);
            }
        });
        var uniqueNames = coders.reduce(function (accum, coder) {
            var name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        var tuple = {};
        coders.forEach(function (coder, index) {
            var name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === 'length') {
                name = '_length';
            }
            if (values[name] != null) {
                return;
            }
            if (_this.name === 'tuple' && _this.localName !== '_') {
                tuple[name] = values[index];
            }
            else {
                values[name] = values[index];
            }
        });
        if (this.name === 'tuple' && this.localName !== '_' && Object.keys(tuple).length === values.length) {
            values = tuple;
        }
        return Object.freeze(values);
    };
    return Coder;
}());
exports.Coder = Coder;
var Writer = (function () {
    function Writer(wordSize) {
        this.wordSize = wordSize || 32;
        this._data = [];
        this._dataLength = 0;
        this._padding = Buffer.alloc(this.wordSize);
    }
    Object.defineProperty(Writer.prototype, "data", {
        get: function () {
            var result = '';
            this._data.forEach(function (item) {
                result += (0, utils_1.hexlify)(item);
            });
            return result;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Writer.prototype, "length", {
        get: function () {
            return this._dataLength;
        },
        enumerable: false,
        configurable: true
    });
    Writer.prototype._writeData = function (data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    };
    Writer.prototype.appendWriter = function (writer) {
        return this._writeData(Buffer.concat(writer._data));
    };
    Writer.prototype.writeBytes = function (value) {
        if (typeof (value) === 'string') {
            value = Buffer.from(value, 'utf8');
        }
        var bytes = (0, utils_1.arrayify)(value);
        var paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
            bytes = Buffer.concat([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
    };
    Writer.prototype._getValue = function (value) {
        if (value instanceof BigNumber) {
            value = value.toString(16);
        }
        var bytes = (0, utils_1.arrayify)(value);
        if (bytes.length > this.wordSize) {
            throw new Error("value out-of-bounds ".concat(this.wordSize, " ").concat(bytes.length));
        }
        if (bytes.length % this.wordSize) {
            bytes = Buffer.concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
    };
    Writer.prototype.writeValue = function (value) {
        return this._writeData(this._getValue(value));
    };
    Writer.prototype.writeUpdatableValue = function () {
        var _this = this;
        var offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return function (value) {
            _this._data[offset] = _this._getValue(value);
        };
    };
    return Writer;
}());
exports.Writer = Writer;
var Reader = (function () {
    function Reader(data, wordSize, allowLoose) {
        this._data = (0, utils_1.arrayify)(data);
        this.wordSize = wordSize || 32;
        this.allowLoose = allowLoose;
        this._offset = 0;
    }
    Object.defineProperty(Reader.prototype, "data", {
        get: function () {
            return (0, utils_1.hexlify)(this._data);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Reader.prototype, "consumed", {
        get: function () {
            return this._offset;
        },
        enumerable: false,
        configurable: true
    });
    Reader.prototype.coerce = function (coder, value) {
        if (coder.name.match('^u?int([0-9]+)$')) {
            value = value.toString();
        }
        return value;
    };
    Reader.prototype._peekBytes = function (offset, length, loose) {
        var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                alignedLength = length;
            }
            else {
                throw new Error("data out-of-bounds: ".concat(this._offset + alignedLength, ", actual: ").concat(this._data.length));
            }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    };
    Reader.prototype.subReader = function (offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this.allowLoose);
    };
    Reader.prototype.readBytes = function (length, loose) {
        var bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        return bytes.slice(0, length);
    };
    Reader.prototype.readValue = function () {
        return new BigNumber(this.readBytes(this.wordSize));
    };
    return Reader;
}());
exports.Reader = Reader;
