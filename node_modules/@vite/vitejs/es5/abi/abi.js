"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Abi = void 0;
var abicoder_1 = require("./abicoder");
var fragments_1 = require("./fragments");
var vitejs_utils_1 = require("../utils/index.js");
var utils_1 = require("./utils");
function checkNames(fragment, type, params) {
    params.reduce(function (accum, param) {
        if (param.name) {
            if (accum[param.name]) {
                throw new Error("duplicate ".concat(type, " parameter ").concat(JSON.stringify(param.name), " in ").concat(fragment.format(fragments_1.FormatTypes.Full)));
            }
            accum[param.name] = true;
        }
        return accum;
    }, {});
}
var Abi = (function () {
    function Abi(fragments) {
        var _this = this;
        var abi;
        var jsonParam = (0, utils_1.safeParseJson)(fragments);
        if (jsonParam) {
            fragments = jsonParam;
        }
        if (!Array.isArray(fragments)) {
            fragments = [fragments];
        }
        abi = fragments;
        this.fragments = abi.map(function (fragment) { return fragments_1.Fragment.from(fragment); }).filter(function (fragment) { return (fragment != null); });
        this._abiCoder = Abi.getAbiCoder();
        this.functions = {};
        this.offchains = {};
        this.events = {};
        this.others = {};
        this.fragments.forEach(function (fragment) {
            var bucket = null;
            switch (fragment.type) {
                case fragments_1.FragmentType.Constructor:
                    if (_this.deploy) {
                        console.warn('duplicate definition - constructor');
                        return;
                    }
                    checkNames(fragment, 'input', fragment.inputs);
                    Object.defineProperty(_this, 'deploy', {
                        enumerable: true,
                        value: fragment,
                        writable: false
                    });
                    return;
                case fragments_1.FragmentType.Function:
                case fragments_1.FragmentType.Callback:
                    checkNames(fragment, 'input', fragment.inputs);
                    checkNames(fragment, 'output', fragment.outputs);
                    bucket = _this.functions;
                    break;
                case fragments_1.FragmentType.Offchain:
                    checkNames(fragment, 'input', fragment.inputs);
                    checkNames(fragment, 'output', fragment.outputs);
                    bucket = _this.offchains;
                    break;
                case fragments_1.FragmentType.Event:
                    checkNames(fragment, 'input', fragment.inputs);
                    bucket = _this.events;
                    break;
                case fragments_1.FragmentType.Variable:
                case fragments_1.FragmentType.Fallback:
                case fragments_1.FragmentType.Receive:
                    checkNames(fragment, 'input', fragment.inputs);
                    bucket = _this.others;
                    break;
                default:
                    return;
            }
            var signature = fragment.format();
            if (bucket[signature]) {
                console.warn("duplicate definition - ".concat(signature));
                return;
            }
            bucket[signature] = fragment;
        });
        if (!this.deploy) {
            this.deploy = fragments_1.ConstructorFragment.from({
                payable: false,
                type: 'constructor'
            });
        }
    }
    Abi.from = function (fragments) {
        return new Abi(fragments);
    };
    Abi.getAbiCoder = function () {
        return abicoder_1.defaultAbiCoder;
    };
    Abi.getSighash = function (fragment) {
        return (0, vitejs_utils_1.blake2bHex)(fragment.format(), null, 32).slice(0, 8);
    };
    Abi.getEventTopic = function (eventFragment) {
        return (0, vitejs_utils_1.blake2bHex)(eventFragment.format(), null, 32);
    };
    Abi._getFunctionLike = function (nameOrSighash, _fragments) {
        if (!nameOrSighash) {
            if (Object.keys(_fragments).length !== 1) {
                throw new Error('param(s) missing, methodName or signature or sighash.');
            }
            return _fragments[Object.keys(_fragments)[0]];
        }
        if ((0, vitejs_utils_1.isHexString)(nameOrSighash)) {
            for (var name in _fragments) {
                if (nameOrSighash === Abi.getSighash(_fragments[name])) {
                    return _fragments[name];
                }
            }
            throw new Error("no matching sighash: ".concat(nameOrSighash));
        }
        if (nameOrSighash.indexOf('(') === -1) {
            var name_1 = nameOrSighash.trim();
            var matching = Object.keys(_fragments).filter(function (e) {
                return (e.split('(')[0] === (_fragments[e].type === fragments_1.FragmentType.Callback ? "".concat(name_1, "Callback") : name_1));
            });
            if (matching.length === 0) {
                throw new Error("no matching function: ".concat(name_1));
            }
            else if (matching.length > 1) {
                throw new Error("multiple matching functions: ".concat(name_1));
            }
            return _fragments[matching[0]];
        }
        return undefined;
    };
    Abi.prototype.format = function (format) {
        if (!format) {
            format = fragments_1.FormatTypes.Full;
        }
        if (format === fragments_1.FormatTypes.Sighash) {
            throw new Error('interface does not support formatting sighash');
        }
        var abi = this.fragments.map(function (fragment) { return fragment.format(format); });
        if (format === fragments_1.FormatTypes.Json) {
            return JSON.stringify(abi.map(function (j) { return JSON.parse(j); }));
        }
        return abi;
    };
    Abi.prototype.getFunction = function (nameOrSignatureOrSighash) {
        var result = Abi._getFunctionLike(nameOrSignatureOrSighash, this.functions);
        if (result) {
            return result;
        }
        result = this.functions[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            throw new Error("no matching function signature: ".concat(nameOrSignatureOrSighash));
        }
        return result;
    };
    Abi.prototype.getOffchain = function (nameOrSignatureOrSighash) {
        var result = Abi._getFunctionLike(nameOrSignatureOrSighash, this.offchains);
        if (result) {
            return result;
        }
        result = this.offchains[fragments_1.OffchainFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            throw new Error("no matching offchain signature: ".concat(nameOrSignatureOrSighash));
        }
        return result;
    };
    Abi.prototype.getEvent = function (nameOrSignatureOrTopic) {
        if (!nameOrSignatureOrTopic) {
            if (Object.keys(this.events).length !== 1) {
                throw new Error('[Error] Param(s) missing, eventName or signature or topic.');
            }
            return this.events[Object.keys(this.events)[0]];
        }
        if ((0, vitejs_utils_1.isHexString)(nameOrSignatureOrTopic)) {
            var topichash = nameOrSignatureOrTopic.toLowerCase();
            for (var name in this.events) {
                if (topichash === this.getEventTopic(name)) {
                    return this.events[name];
                }
            }
            throw new Error("no matching topichash: ".concat(topichash));
        }
        if (nameOrSignatureOrTopic.indexOf('(') === -1) {
            var name_2 = nameOrSignatureOrTopic.trim();
            var matching = Object.keys(this.events).filter(function (f) { return (f.split('(')[0] === name_2); });
            if (matching.length === 0) {
                throw new Error("no matching event: ".concat(name_2));
            }
            else if (matching.length > 1) {
                throw new Error("multiple matching events: ".concat(name_2));
            }
            return this.events[matching[0]];
        }
        var result = this.events[fragments_1.EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
            throw new Error("no matching event signature: ".concat(nameOrSignatureOrTopic));
        }
        return result;
    };
    Abi.prototype.getSighash = function (fragment) {
        return Abi.getSighash(this._getFunction(fragment));
    };
    Abi.prototype.getEventTopic = function (eventFragment) {
        return Abi.getEventTopic(this._getEvent(eventFragment));
    };
    Abi.prototype.encodeDeploy = function (values) {
        if (Object.keys(this.deploy.inputs).length === 0) {
            throw new Error('abi has no constructor');
        }
        return this._encodeParams(this.deploy.inputs, values || []);
    };
    Abi.prototype.decodeFunctionData = function (functionFragment, data) {
        var _fragment = this._getFunction(functionFragment);
        var bytes = (0, utils_1.arrayify)(data);
        if ((0, utils_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(_fragment)) {
            throw new Error("data signature does not match function ".concat(_fragment.name, ": ").concat((0, utils_1.hexlify)(bytes.slice(0, 4))));
        }
        return this._decodeParams(_fragment.inputs, bytes.slice(4));
    };
    Abi.prototype.encodeFunctionData = function (functionFragment, values) {
        var _fragment = this._getFunction(functionFragment);
        return (0, utils_1.hexlify)(Abi.getSighash(_fragment).concat(this._encodeParams(_fragment.inputs, values || [])));
    };
    Abi.prototype.decodeFunctionResult = function (functionFragment, data) {
        var _fragment = this._getFunction(functionFragment);
        var bytes = (0, utils_1.arrayify)(data);
        if (bytes.length % this._abiCoder._getWordSize() === 0) {
            return this._abiCoder.decode(_fragment.outputs, bytes);
        }
        throw new Error("decode function output failed: ".concat(_fragment));
    };
    Abi.prototype.encodeFunctionResult = function (functionFragment, values) {
        var _fragment = this._getFunction(functionFragment);
        return (0, utils_1.hexlify)(this._abiCoder.encode(_fragment.outputs, values || []));
    };
    Abi.prototype.encodeOffchainData = function (offchainFragment, values) {
        var _fragment = this._getOffchain(offchainFragment);
        return (0, utils_1.hexlify)(Abi.getSighash(_fragment).concat(this._encodeParams(_fragment.inputs, values || [])));
    };
    Abi.prototype.decodeOffchainResult = function (offchainFragment, data) {
        var _fragment = this._getOffchain(offchainFragment);
        var bytes = (0, utils_1.arrayify)(data);
        if (bytes.length % this._abiCoder._getWordSize() === 0) {
            return this._abiCoder.decode(_fragment.outputs, bytes);
        }
        throw new Error("decode offchain output failed: ".concat(_fragment));
    };
    Abi.prototype.encodeFilterTopics = function (eventFragment, values) {
        var _this = this;
        var _fragment = this._getEvent(eventFragment);
        if (values.length > _fragment.inputs.length) {
            throw new Error("too many arguments for ".concat(_fragment.format(), ": ").concat(values));
        }
        var topics = [];
        if (!_fragment.anonymous) {
            topics.push(this.getEventTopic(_fragment));
        }
        var encodeTopic = function (param, value, _isSubElement) {
            if (param.type === 'string') {
                if (_isSubElement) {
                    return (0, utils_1.rightPadZero)(Buffer.from(value, 'utf8'), 32);
                }
                return (0, vitejs_utils_1.blake2bHex)(value, null, 32);
            }
            else if (param.type === 'bytes') {
                if (_isSubElement) {
                    return (0, utils_1.rightPadZero)(value, 32);
                }
                return (0, vitejs_utils_1.blake2bHex)((value), null, 32);
            }
            else if (param.baseType === 'tuple') {
                if (!(0, vitejs_utils_1.isObject)(value)) {
                    throw new Error("type error, expect object but got ".concat(typeof value));
                }
                var result = param.components.reduce(function (accum, item) {
                    if (value[item.name] === undefined) {
                        throw new Error("missing tuple property: ".concat(item.name));
                    }
                    return accum.concat(encodeTopic(item, value[item.name], true));
                }, '');
                if (_isSubElement) {
                    return result;
                }
                return (0, vitejs_utils_1.blake2bHex)((0, utils_1.arrayify)(result), null, 32);
            }
            else if (param.baseType === 'array') {
                if (!Array.isArray(value)) {
                    throw new Error("type error, expect array but got ".concat(typeof value));
                }
                var result = value.reduce(function (accum, item) { return accum.concat(encodeTopic(param.arrayChildren, item, true)); }, '');
                if (_isSubElement) {
                    return result;
                }
                return (0, vitejs_utils_1.blake2bHex)((0, utils_1.arrayify)(result), null, 32);
            }
            return _this._abiCoder.encode([param.type], [value]);
        };
        var _inputs = _fragment.inputs.filter(function (item) { return item.indexed; });
        if (values.length > _inputs.length) {
            throw new Error("too many indexed arguments for ".concat(_fragment.format(), ": ").concat(values));
        }
        values.forEach(function (value, index) {
            var param = _inputs[index];
            if (!param.indexed) {
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (Array.isArray(value) && (param.baseType !== 'array' || (0, utils_1.getArrayDepth)(value) > param.arrayDimension)) {
                if ((0, utils_1.getArrayDepth)(value) > 1 + param.arrayDimension) {
                    throw new Error("incorrect filter format, expected input depth: ".concat(1 + param.arrayDimension, ", actual: ").concat((0, utils_1.getArrayDepth)(value)));
                }
                topics.push(value.map(function (value) { return encodeTopic(param, value); }));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    };
    Abi.prototype.encodeEventLog = function (eventFragment, values) {
        var _this = this;
        var _fragment = this._getEvent(eventFragment);
        var topics = [];
        var dataTypes = [];
        var dataValues = [];
        if (!_fragment.anonymous) {
            topics.push(this.getEventTopic(_fragment));
        }
        if (values.length !== _fragment.inputs.length) {
            throw new Error("event arguments/values mismatch: ".concat(values));
        }
        _fragment.inputs.forEach(function (param, index) {
            var value = values[index];
            if (param.indexed) {
                if (param.type === 'string') {
                    topics.push((0, vitejs_utils_1.blake2bHex)(value, null, 32));
                }
                else if (param.type === 'bytes') {
                    topics.push((0, vitejs_utils_1.blake2bHex)(value, null, 32));
                }
                else if (param.baseType === 'tuple' || param.baseType === 'array') {
                    throw new Error('encoding event log for tuple or array is not implemented');
                }
                else {
                    topics.push(_this._abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    };
    Abi.prototype.decodeEventLog = function (eventFragment, data, topics) {
        var _fragment = this._getEvent(eventFragment);
        if (topics != null && !_fragment.anonymous) {
            var topicHash = this.getEventTopic(_fragment);
            if (!(0, vitejs_utils_1.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                throw new Error("fragment/topic mismatch, expected: ".concat(topicHash, ", actual: ").concat(topics[0]));
            }
            topics = topics.slice(1);
        }
        var indexed = [];
        var nonIndexed = [];
        _fragment.inputs.forEach(function (param, index) {
            if (param.indexed) {
                if (param.type === 'string' || param.type === 'bytes' || param.baseType === 'tuple' || param.baseType === 'array') {
                    indexed.push(fragments_1.ParamType.fromObject({ type: 'bytes32', name: param.name }));
                }
                else {
                    indexed.push(param);
                }
            }
            else {
                nonIndexed.push(param);
            }
        });
        var resultIndexed = (!topics || topics.length === 0) ? null : this._abiCoder.decode(indexed, Buffer.concat(topics.map(function (item) { return (0, utils_1.arrayify)(item); })));
        var resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        var result = {};
        var nonIndexedIndex = 0, indexedIndex = 0;
        _fragment.inputs.forEach(function (param, index) {
            if (param.indexed) {
                if (resultIndexed == null) {
                    result[index] = null;
                }
                else {
                    result[index] = resultIndexed[indexedIndex++];
                }
            }
            else {
                result[index] = resultNonIndexed[nonIndexedIndex++];
            }
            if (param.name && result[param.name] == null) {
                result[param.name] = result[index];
            }
        });
        return Object.freeze(result);
    };
    Abi.prototype._decodeParams = function (params, data) {
        return this._abiCoder.decode(params, data);
    };
    Abi.prototype._encodeParams = function (params, values) {
        return this._abiCoder.encode(params, values);
    };
    Abi.prototype._getFunction = function (functionFragment) {
        if (!functionFragment) {
            functionFragment = this.getFunction();
        }
        if (typeof (functionFragment) === 'string') {
            functionFragment = this.getFunction(functionFragment);
        }
        return functionFragment;
    };
    Abi.prototype._getOffchain = function (functionFragment) {
        if (!functionFragment) {
            functionFragment = this.getOffchain();
        }
        if (typeof (functionFragment) === 'string') {
            functionFragment = this.getOffchain(functionFragment);
        }
        return functionFragment;
    };
    Abi.prototype._getEvent = function (eventFragment) {
        if (!eventFragment) {
            eventFragment = this.getEvent();
        }
        if (typeof (eventFragment) === 'string') {
            eventFragment = this.getEvent(eventFragment);
        }
        return eventFragment;
    };
    return Abi;
}());
exports.Abi = Abi;
