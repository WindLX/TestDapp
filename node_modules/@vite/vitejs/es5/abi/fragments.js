"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultFragment = exports.OffchainFragment = exports.FunctionFragment = exports.ConstructorFragment = exports.EventFragment = exports.Fragment = exports.FragmentType = exports.ParamType = exports.FormatTypes = void 0;
var utils_1 = require("./utils");
var ModifiersBytes = { calldata: true, memory: true, storage: true };
var ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
    if (type === 'bytes' || type === 'string') {
        if (ModifiersBytes[name]) {
            return true;
        }
    }
    else if (type === 'address') {
        if (name === 'payable') {
            return true;
        }
    }
    else if (type.indexOf('[') >= 0 || type === 'tuple') {
        if (ModifiersNest[name]) {
            return true;
        }
    }
    if (ModifiersBytes[name] || name === 'payable') {
        throw new Error("invalid modifier ".concat(name));
    }
    return false;
}
function parseParamType(param, allowIndexed) {
    var originalParam = param;
    function throwError(i) {
        throw new Error("unexpected character at position ".concat(i, " of ").concat(param));
    }
    param = param.replace(/\s/g, ' ');
    function newNode(parent) {
        var node = { type: '', name: '', parent: parent, state: { allowType: true } };
        if (allowIndexed) {
            node.indexed = false;
        }
        return node;
    }
    var parent = { type: '', name: '', state: { allowType: true } };
    var node = parent;
    for (var i = 0; i < param.length; i++) {
        var c = param[i];
        switch (c) {
            case '(':
                if (node.state.allowType && node.type === '') {
                    node.type = 'tuple';
                }
                else if (!node.state.allowParams) {
                    throwError(i);
                }
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;
            case ')': {
                delete node.state;
                if (node.name === 'indexed') {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = '';
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = '';
                }
                node.type = verifyType(node.type);
                var child = node;
                node = node.parent;
                if (!node) {
                    throwError(i);
                }
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            }
            case ',':
                delete node.state;
                if (node.name === 'indexed') {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = '';
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = '';
                }
                node.type = verifyType(node.type);
                var sibling = newNode(node.parent);
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            case ' ':
                if (node.state.allowType) {
                    if (node.type !== '') {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                if (node.state.allowName) {
                    if (node.name !== '') {
                        if (node.name === 'indexed') {
                            if (!allowIndexed) {
                                throwError(i);
                            }
                            if (node.indexed) {
                                throwError(i);
                            }
                            node.indexed = true;
                            node.name = '';
                        }
                        else if (checkModifier(node.type, node.name)) {
                            node.name = '';
                        }
                        else {
                            node.state.allowName = false;
                        }
                    }
                }
                break;
            case '[':
                if (!node.state.allowArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case ']':
                if (!node.state.readArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                }
                else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                }
                else if (node.state.readArray) {
                    node.type += c;
                }
                else {
                    throwError(i);
                }
        }
    }
    if (node.parent) {
        throw new Error("unexpected eof param ".concat(param));
    }
    delete parent.state;
    if (node.name === 'indexed') {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }
        if (node.indexed) {
            throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = '';
    }
    else if (checkModifier(node.type, node.name)) {
        node.name = '';
    }
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for (var key in params) {
        Object.defineProperty(object, key, {
            enumerable: true,
            value: params[key],
            writable: false
        });
    }
}
var FormatTypes;
(function (FormatTypes) {
    FormatTypes["Sighash"] = "sighash";
    FormatTypes["Minimal"] = "minimal";
    FormatTypes["Full"] = "full";
    FormatTypes["Json"] = "json";
})(FormatTypes = exports.FormatTypes || (exports.FormatTypes = {}));
var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
var ParamType = (function () {
    function ParamType(params) {
        populate(this, params);
        var match = this.type.match(paramTypeArray);
        if (match) {
            populate(this, {
                arrayLength: parseInt(match[2] || '-1'),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                arrayDimension: this.type.match(/\[([0-9]*)\]/g).length,
                baseType: 'array'
            });
        }
        else {
            populate(this, {
                arrayLength: null,
                arrayChildren: null,
                arrayDimension: null,
                baseType: ((this.components == null) ? this.type : 'tuple')
            });
        }
        this._isParamType = true;
        Object.freeze(this);
    }
    ParamType.from = function (value, allowIndexed) {
        if (typeof (value) === 'string') {
            var jsonParam = (0, utils_1.safeParseJson)(value);
            if (jsonParam) {
                value = jsonParam;
            }
            else {
                return ParamType.fromString(value, allowIndexed);
            }
        }
        return ParamType.fromObject(value);
    };
    ParamType.fromObject = function (value) {
        if (ParamType.isParamType(value)) {
            return value;
        }
        return new ParamType({
            name: (value.name || null),
            type: verifyType(value.type),
            indexed: ((value.indexed == null) ? null : !!value.indexed),
            components: (value.components ? value.components.map(ParamType.fromObject) : null)
        });
    };
    ParamType.fromString = function (value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    };
    ParamType.isParamType = function (value) {
        return !!(value != null && value._isParamType);
    };
    ParamType.prototype.format = function (format) {
        if (!format) {
            format = FormatTypes.Sighash;
        }
        if (format === FormatTypes.Json) {
            var result_1 = {
                type: ((this.baseType === 'tuple') ? 'tuple' : this.type),
                name: (this.name || undefined)
            };
            if (typeof (this.indexed) === 'boolean') {
                result_1.indexed = this.indexed;
            }
            if (this.components) {
                result_1.components = this.components.map(function (comp) { return JSON.parse(comp.format(format)); });
            }
            return JSON.stringify(result_1);
        }
        var result = '';
        if (this.baseType === 'array') {
            result += this.arrayChildren.format(format);
            result += "[".concat(this.arrayLength < 0 ? '' : String(this.arrayLength), "]");
        }
        else if (this.baseType === 'tuple') {
            if (format !== FormatTypes.Sighash) {
                result += this.type;
            }
            result += "(".concat(this.components.map(function (comp) { return comp.format(format); }).join((format === FormatTypes.Full) ? ', ' : ','), ")");
        }
        else {
            result += this.type;
        }
        if (format !== FormatTypes.Sighash) {
            if (this.indexed === true) {
                result += ' indexed';
            }
            if (format === FormatTypes.Full && this.name) {
                result += " ".concat(this.name);
            }
        }
        return result;
    };
    return ParamType;
}());
exports.ParamType = ParamType;
function parseParams(value, allowIndex) {
    return splitNesting(value).map(function (param) { return ParamType.fromString(param, allowIndex); });
}
var FragmentType;
(function (FragmentType) {
    FragmentType["Function"] = "function";
    FragmentType["Event"] = "event";
    FragmentType["Constructor"] = "constructor";
    FragmentType["Offchain"] = "offchain";
    FragmentType["Callback"] = "callback";
    FragmentType["Variable"] = "variable";
    FragmentType["Fallback"] = "fallback";
    FragmentType["Receive"] = "receive";
})(FragmentType = exports.FragmentType || (exports.FragmentType = {}));
var Fragment = (function () {
    function Fragment(params) {
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    Fragment.from = function (value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        if (typeof (value) === 'string') {
            var jsonFragment = (0, utils_1.safeParseJson)(value);
            if (jsonFragment) {
                value = jsonFragment;
            }
            else {
                return Fragment.fromString(value);
            }
        }
        return Fragment.fromObject(value);
    };
    Fragment.fromObject = function (value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        switch (value.type) {
            case FragmentType.Function:
            case FragmentType.Callback:
                return FunctionFragment.fromObject(value);
            case FragmentType.Event:
                return EventFragment.fromObject(value);
            case FragmentType.Constructor:
                return ConstructorFragment.fromObject(value);
            case FragmentType.Offchain:
                return OffchainFragment.fromObject(value);
            case FragmentType.Variable:
            case FragmentType.Fallback:
            case FragmentType.Receive:
                return DefaultFragment.fromObject(value);
        }
        throw new Error("invalid fragment object ".concat(value));
    };
    Fragment.fromString = function (value) {
        value = value.replace(/\s/g, ' ');
        value = value.replace(/\(/g, ' (').replace(/\)/g, ') ').replace(/\s+/g, ' ');
        value = value.trim();
        if (value.split(' ')[0] === FragmentType.Event) {
            return EventFragment.fromString(value.substring(5).trim());
        }
        else if (value.split(' ')[0] === FragmentType.Function
            || value.split(' ')[0] === FragmentType.Callback) {
            return FunctionFragment.fromString(value.substring(8).trim(), value.split(' ')[0]);
        }
        else if (value.split('(')[0].trim() === FragmentType.Constructor) {
            return ConstructorFragment.fromString(value.trim());
        }
        else if (value.split(' ')[0] === FragmentType.Offchain) {
            return OffchainFragment.fromString(value.substring(8).trim());
        }
        else if (value.split(' ')[0] === 'getter') {
            return OffchainFragment.fromString(value.substring(6).trim());
        }
        else if (value.split('(')[0].trim() === FragmentType.Receive
            || value.split('(')[0].trim() === FragmentType.Fallback
            || value.split(' ')[0] === FragmentType.Variable) {
            return DefaultFragment.fromString(value.trim());
        }
        throw new Error("unsupported fragment ".concat(value));
    };
    Fragment.isFragment = function (value) {
        return !!(value && value._isFragment);
    };
    return Fragment;
}());
exports.Fragment = Fragment;
var EventFragment = (function (_super) {
    __extends(EventFragment, _super);
    function EventFragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EventFragment.from = function (value) {
        if (typeof (value) === 'string') {
            return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
    };
    EventFragment.fromObject = function (value) {
        if (EventFragment.isEventFragment(value)) {
            return value;
        }
        if (value.type !== FragmentType.Event) {
            throw new Error("invalid event object ".concat(value));
        }
        var params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            type: FragmentType.Event
        };
        if (params.inputs.filter(function (item) { return item.indexed; }).length > 3) {
            throw new Error("only up to 3 params can be indexed: ".concat(params.name));
        }
        return new EventFragment(params);
    };
    EventFragment.fromString = function (value) {
        var match = value.match(regexParen);
        if (!match) {
            throw new Error("invalid event string ".concat(value));
        }
        var anonymous = false;
        match[3].split(' ').forEach(function (modifier) {
            switch (modifier.trim()) {
                case 'anonymous':
                    anonymous = true;
                    break;
                case '':
                    break;
                default:
                    console.warn("unknown modifier: ".concat(modifier));
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: FragmentType.Event
        });
    };
    EventFragment.isEventFragment = function (value) {
        return (value && value._isFragment && value.type === FragmentType.Event);
    };
    EventFragment.prototype.format = function (format) {
        if (!format) {
            format = FormatTypes.Sighash;
        }
        if (format === FormatTypes.Json) {
            return JSON.stringify({
                type: FragmentType.Event,
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })
            });
        }
        var result = '';
        if (format !== FormatTypes.Sighash) {
            result += 'event ';
        }
        result += "".concat(this.name, "(").concat(this.inputs.map(function (input) { return input.format(format); }).join((format === FormatTypes.Full) ? ', ' : ','), ") ");
        if (format !== FormatTypes.Sighash) {
            if (this.anonymous) {
                result += 'anonymous ';
            }
        }
        return result.trim();
    };
    return EventFragment;
}(Fragment));
exports.EventFragment = EventFragment;
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = 'nonpayable';
    value.split(' ').forEach(function (modifier) {
        switch (modifier.trim()) {
            case 'constant':
                params.constant = true;
                break;
            case 'payable':
                params.payable = true;
                params.stateMutability = 'payable';
                break;
            case 'nonpayable':
                params.payable = false;
                params.stateMutability = 'nonpayable';
                break;
            case 'pure':
                params.constant = true;
                params.stateMutability = 'pure';
                break;
            case 'view':
                params.constant = true;
                params.stateMutability = 'view';
                break;
            case 'external':
            case 'public':
            case '':
                break;
            default:
                console.log("unknown modifier: ".concat(modifier));
        }
    });
}
function verifyState(value) {
    var result = {
        constant: false,
        payable: false,
        stateMutability: 'nonpayable'
    };
    if (value.type === FragmentType.Offchain) {
        result.constant = true;
        result.stateMutability = 'view';
    }
    else if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        result.constant = (result.stateMutability === 'view' || result.stateMutability === 'pure');
        if (value.constant != null) {
            if ((!!value.constant) !== result.constant) {
                throw new Error("cannot have constant function with mutability ".concat(result.stateMutability, " ").concat(value));
            }
        }
        result.payable = (result.stateMutability === 'payable');
        if (value.payable != null) {
            if ((!!value.payable) !== result.payable) {
                throw new Error("cannot have payable function with mutability ".concat(result.stateMutability, " ").concat(value));
            }
        }
    }
    else if (value.payable != null) {
        result.payable = !!value.payable;
        result.constant = !!value.constant;
        if (result.constant) {
            result.stateMutability = 'view';
        }
        else {
            result.stateMutability = (result.payable ? 'payable' : 'nonpayable');
        }
        if (result.payable && result.constant) {
            throw new Error("cannot have constant payable function ".concat(value));
        }
    }
    else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = (result.constant ? 'view' : 'payable');
    }
    return result;
}
var ConstructorFragment = (function (_super) {
    __extends(ConstructorFragment, _super);
    function ConstructorFragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ConstructorFragment.from = function (value) {
        if (typeof (value) === 'string') {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    };
    ConstructorFragment.fromObject = function (value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== FragmentType.Constructor) {
            throw new Error("invalid constructor object ".concat(value));
        }
        var state = verifyState(value);
        if (state.constant) {
            throw new Error("constructor cannot be constant ".concat(value));
        }
        var params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability
        };
        return new ConstructorFragment(params);
    };
    ConstructorFragment.fromString = function (value) {
        var params = { type: FragmentType.Constructor };
        var parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== 'constructor') {
            throw new Error("invalid constructor string ".concat(value));
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    };
    ConstructorFragment.isConstructorFragment = function (value) {
        return (value && value._isFragment && value.type === FragmentType.Constructor);
    };
    ConstructorFragment.prototype.format = function (format) {
        if (!format) {
            format = FormatTypes.Sighash;
        }
        if (format === FormatTypes.Json) {
            return JSON.stringify({
                type: FragmentType.Constructor,
                stateMutability: ((this.stateMutability === 'nonpayable') ? undefined : this.stateMutability),
                payable: this.payable,
                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })
            });
        }
        if (format === FormatTypes.Sighash) {
            throw new Error('cannot format a constructor for sighash');
        }
        var result = "constructor(".concat(this.inputs.map(function (input) { return input.format(format); }).join((format === FormatTypes.Full) ? ', ' : ','), ") ");
        if (this.stateMutability && this.stateMutability !== 'nonpayable') {
            result += "".concat(this.stateMutability, " ");
        }
        return result.trim();
    };
    return ConstructorFragment;
}(Fragment));
exports.ConstructorFragment = ConstructorFragment;
var FunctionFragment = (function (_super) {
    __extends(FunctionFragment, _super);
    function FunctionFragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FunctionFragment.from = function (value) {
        if (typeof (value) === 'string') {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    };
    FunctionFragment.fromObject = function (value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== FragmentType.Function && value.type !== FragmentType.Callback) {
            throw new Error("invalid function object ".concat(value));
        }
        var state = verifyState(value);
        var params = {
            type: value.type,
            name: verifyIdentifier(value.type === FragmentType.Callback ? "".concat(value.name, "Callback") : value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability
        };
        return new FunctionFragment(params);
    };
    FunctionFragment.fromString = function (value, type) {
        if (!type) {
            type = FragmentType.Function;
        }
        var params = { type: type };
        var comps = value.split(' returns ');
        if (comps.length > 2) {
            throw new Error("invalid function string ".concat(value));
        }
        var parens = comps[0].match(regexParen);
        if (!parens) {
            throw new Error("invalid function signature ".concat(value));
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        if (comps.length > 1) {
            var returns = comps[1].match(regexParen);
            if (returns[1].trim() !== '' || returns[3].trim() !== '') {
                throw new Error("unexpected tokens ".concat(value));
            }
            params.outputs = parseParams(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    };
    FunctionFragment.isFunctionFragment = function (value) {
        return (value && value._isFragment && (value.type === FragmentType.Function || value.type === FragmentType.Callback));
    };
    FunctionFragment.prototype.format = function (format) {
        if (!format) {
            format = FormatTypes.Sighash;
        }
        var _name = this.name;
        if (format !== FormatTypes.Sighash && this.type === FragmentType.Callback) {
            _name = this.name.replace(/Callback$/, '');
        }
        if (format === FormatTypes.Json) {
            return JSON.stringify({
                type: this.type,
                name: _name,
                constant: this.constant,
                stateMutability: ((this.stateMutability === 'nonpayable') ? undefined : this.stateMutability),
                payable: this.payable,
                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),
                outputs: this.outputs.map(function (output) { return JSON.parse(output.format(format)); })
            });
        }
        var result = '';
        if (format !== FormatTypes.Sighash) {
            result += "".concat(this.type, " ");
        }
        result += "".concat(_name, "(").concat(this.inputs.map(function (input) { return input.format(format); }).join((format === FormatTypes.Full) ? ', ' : ','), ") ");
        if (format !== FormatTypes.Sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== 'nonpayable') {
                    result += ("".concat(this.stateMutability, " "));
                }
            }
            else if (this.constant) {
                result += 'view ';
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (".concat(this.outputs.map(function (output) { return output.format(format); }).join(', '), ") ");
            }
        }
        return result.trim();
    };
    return FunctionFragment;
}(Fragment));
exports.FunctionFragment = FunctionFragment;
var OffchainFragment = (function (_super) {
    __extends(OffchainFragment, _super);
    function OffchainFragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OffchainFragment.from = function (value) {
        if (typeof (value) === 'string') {
            return OffchainFragment.fromString(value);
        }
        return OffchainFragment.fromObject(value);
    };
    OffchainFragment.fromObject = function (value) {
        if (OffchainFragment.isOffchainFragment(value)) {
            return value;
        }
        if (value.type !== FragmentType.Offchain) {
            throw new Error("invalid offchain object ".concat(value));
        }
        var params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : [])
        };
        return new OffchainFragment(params);
    };
    OffchainFragment.fromString = function (value) {
        var functionParams = FunctionFragment.fromString(value);
        var params = {
            type: FragmentType.Offchain,
            name: functionParams.name,
            inputs: functionParams.inputs,
            outputs: functionParams.outputs
        };
        return new OffchainFragment(params);
    };
    OffchainFragment.isOffchainFragment = function (value) {
        return (value && value._isFragment && value.type === FragmentType.Offchain);
    };
    OffchainFragment.prototype.format = function (format) {
        if (!format) {
            format = FormatTypes.Sighash;
        }
        if (format === FormatTypes.Json) {
            return JSON.stringify({
                type: FragmentType.Offchain,
                name: this.name,
                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),
                outputs: this.outputs.map(function (output) { return JSON.parse(output.format(format)); })
            });
        }
        var result = '';
        if (format !== FormatTypes.Sighash) {
            result += 'getter ';
        }
        result += "".concat(this.name, "(").concat(this.inputs.map(function (input) { return input.format(format); }).join((format === FormatTypes.Full) ? ', ' : ','), ") ");
        if (format !== FormatTypes.Sighash) {
            if (this.outputs && this.outputs.length) {
                result += "returns (".concat(this.outputs.map(function (output) { return output.format(format); }).join(', '), ") ");
            }
        }
        return result.trim();
    };
    return OffchainFragment;
}(Fragment));
exports.OffchainFragment = OffchainFragment;
var DefaultFragment = (function (_super) {
    __extends(DefaultFragment, _super);
    function DefaultFragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultFragment.from = function (value) {
        if (typeof (value) === 'string') {
            return DefaultFragment.fromString(value);
        }
        return DefaultFragment.fromObject(value);
    };
    DefaultFragment.fromObject = function (value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        if (!Object.values(FragmentType).includes(value.type)) {
            throw new Error("invalid fragment object ".concat(value));
        }
        var state = verifyState(value);
        var params = {
            type: value.type,
            name: value.name ? value.name : undefined,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability
        };
        return new DefaultFragment(params);
    };
    DefaultFragment.fromString = function (value) {
        var params = {};
        var parens = value.match(regexParen);
        var type = parens && parens[1].trim();
        if (!Object.values(FragmentType).includes(type)) {
            throw new Error("invalid fragment object ".concat(value));
        }
        params.type = type;
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return DefaultFragment.fromObject(params);
    };
    DefaultFragment.prototype.format = function (format) {
        if (!format) {
            format = FormatTypes.Sighash;
        }
        if (format === FormatTypes.Json) {
            return JSON.stringify({
                type: this.type,
                name: this.name ? this.name : undefined,
                stateMutability: ((this.stateMutability === 'nonpayable') ? undefined : this.stateMutability),
                payable: this.payable,
                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })
            });
        }
        var result = '';
        if ([FragmentType.Receive, FragmentType.Fallback, FragmentType.Constructor].includes(this.type)) {
            result = "".concat(this.type, "(").concat(this.inputs.map(function (input) { return input.format(format); }).join((format === FormatTypes.Full) ? ', ' : ','), ") ");
        }
        else {
            if (format !== FormatTypes.Sighash) {
                result += "".concat(this.type, " ");
            }
            result += "".concat(this.name, "(").concat(this.inputs.map(function (input) { return input.format(format); }).join((format === FormatTypes.Full) ? ', ' : ','), ") ");
        }
        if (format !== FormatTypes.Sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== 'nonpayable') {
                    result += ("".concat(this.stateMutability, " "));
                }
            }
        }
        return result.trim();
    };
    return DefaultFragment;
}(Fragment));
exports.DefaultFragment = DefaultFragment;
function verifyType(type) {
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256".concat(type.substring(4));
    }
    else if (type.match(/^int($|[^1-9])/)) {
        type = "int256".concat(type.substring(3));
    }
    var isArray = /^\w+(\[\d*\])+$/g.test(type);
    var isPrimitive = /^\w+\d*$/g.test(type);
    if (!isArray && !isPrimitive) {
        throw new Error("illegal type: ".concat(type));
    }
    var _type = type.match(/^[a-zA-Z]+/g);
    var baseType = _type && _type[0];
    if (!baseType || typePrefix.indexOf(baseType) === -1) {
        throw new Error("illegal type: ".concat(type));
    }
    var _size;
    if (isArray) {
        _size = type.split('[')[0].match(getNum);
    }
    else {
        _size = type.match(getNum);
    }
    var size = _size ? _size[0] : 0;
    if (baseType === 'bytes' && size && !(size > 0 && size <= 32)) {
        throw new Error("illegal type: ".concat(type, ". Binary type of\u00A0M\u00A0bytes,\u00A00\u00A0<\u00A0M\u00A0<=\u00A032. Or dynamic sized byte sequence."));
    }
    if ((baseType === 'int' || baseType === 'uint') && size && !(size > 0 && size <= 256 && size % 8 === 0)) {
        throw new Error("illegal type: ".concat(type, ". Unsigned integer type of\u00A0M\u00A0bits,\u00A00\u00A0<\u00A0M\u00A0<=\u00A0256,\u00A0M\u00A0%\u00A08\u00A0==\u00A00. e.g.\u00A0uint32,\u00A0uint8,\u00A0uint256."));
    }
    return type;
}
var typePrefix = ['uint', 'int', 'address', 'bool', 'bytes', 'string', 'tokenId', 'gid', 'tuple'];
var getNum = new RegExp(/(\d+)/g);
var regexIdentifier = new RegExp('^[a-zA-Z$_][a-zA-Z0-9$_]*$');
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        throw new Error("invalid identifier: ".concat(value));
    }
    return value;
}
var regexParen = new RegExp('^([^)(]*)\\((.*)\\)([^)(]*)$');
function splitNesting(value) {
    value = value.trim();
    var result = [];
    var accum = '';
    var depth = 0;
    for (var offset = 0; offset < value.length; offset++) {
        var c = value[offset];
        if (c === ',' && depth === 0) {
            result.push(accum);
            accum = '';
        }
        else {
            accum += c;
            if (c === '(') {
                depth++;
            }
            else if (c === ')') {
                depth--;
                if (depth === -1) {
                    throw new Error("unbalanced parenthesis ".concat(value));
                }
            }
        }
    }
    if (accum) {
        result.push(accum);
    }
    return result;
}
